"""Recursive Self-Aggregation (RSA) - A general-purpose LLM aggregation algorithm using litellm"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto #0
__all__ = ['RSACandidate', 'RSA']

# %% ../nbs/00_core.ipynb #ccd7cb56
from fastcore.all import *
from fastcore.test import *
from litellm import completion
import random, uuid

# %% ../nbs/00_core.ipynb #c8def011
class RSACandidate:
    "A candidate response in the RSA algorithm"
    def __init__(self, id:str, loop_id:int, prompt:str, response:str=None, parent_ids:list=None): store_attr()
    def __repr__(self): return f'id:{self.id}\nloop_id:{self.loop_id}\nprompt:\n{self.prompt}\nresponse:\n{self.response}\nparent_ids:\n{self.parent_ids}'

# %% ../nbs/00_core.ipynb #cc5af69e
class RSA:
    "Recursive Self-Aggregation algorithm for LLM response aggregation"
    def __init__(
        self,
        task_prompt:str,  # The main task/question to solve
        agg_prompt:str=None,  # Custom aggregation prompt
        model:str='openrouter/google/gemini-3-flash-preview',  # LLM model to use
        M:int=8,  # Number of candidates per loop
        k:int=4,  # Number of candidates to aggregate
        loops:int=3,  # Number of aggregation loops
        history:list=None,  # History of all candidates
        temperature:float=1.0,  # LLM temperature
        n_workers:int=4  # Parallel workers
    ): 
        if not task_prompt: raise ValueError("task_prompt is required")
        store_attr()
        if not history: self.history = []
    
    def __repr__(self): return f'RSA(model={self.model!r}, \nM={self.M}, \nk={self.k}, \nloops={self.loops}, \nhistory={len(self.history)} candidates, \ntask_prompt={self.task_prompt})'

# %% ../nbs/00_core.ipynb #3c39e9e6
@patch
def _call_llm(self:RSA, prompt):
    response = completion(
        model=self.model,
        messages=[{"role": "user", "content": prompt}],
        temperature=self.temperature
    )
    return response.choices[0].message.content

# %% ../nbs/00_core.ipynb #ef493c51
@patch
def _agg_prompt(self:RSA, candidates: List[RSACandidate]) -> str:
    if not self.agg_prompt: self.agg_prompt = """You are given question with training examples and a test input.\nYou are also provided several candidate solutions. Some candidates may be incorrect...,\nAggregate/consider all the candidates and use their help to produce the improved correct solution..."""
    parts = [
        self.agg_prompt,
        self.task_prompt,
        "\nCANDIDATE ANSWERS (may contain mistakes):",
    ]
    for i, cand in enumerate(candidates, 1):
        parts.append(f"---- Candidate {i} ----\n{cand.response}")
    parts.append("\nYour response:")
    return "\n".join(parts)

# %% ../nbs/00_core.ipynb #81deb527
@patch
def get_prompts(self:RSA, loop_id, cands=None):
    if not cands: return L(RSACandidate(id=str(uuid.uuid4()), loop_id=loop_id, prompt=self.task_prompt) for _ in range(self.M))
    sel_cands = L.range(self.M).map(lambda _: L(random.sample(cands, self.k)))
    return sel_cands.map(lambda x: RSACandidate(id=str(uuid.uuid4()), loop_id=loop_id, prompt=self._agg_prompt(x), parent_ids=x.attrgot('id')))

# %% ../nbs/00_core.ipynb #80329d80
@patch
def _run_loop(self:RSA, loop_id, pool=None):
    prompts = self.get_prompts(loop_id, pool)
    responses = parallel(self._call_llm, prompts.attrgot('prompt'), n_workers=self.n_workers)
    for p, r in zip(prompts, responses): p.response = r
    return prompts

# %% ../nbs/00_core.ipynb #02599e94
@patch
def run(self:RSA):
    pool = self._run_loop(0)
    self.history.extend(pool)
    for i in range(1, self.loops):
        pool = self._run_loop(i, pool)
        self.history.extend(pool)
    return pool
